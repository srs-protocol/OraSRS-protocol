{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_19-22d079e1c32bc46a1bc5b10cbc249f0401cf74f3",
  "solcVersion": "0.8.19",
  "solcLongVersion": "0.8.19+commit.7dd6d404",
  "userSourceNameMap": {
    "isolated_contracts/CrossChainInterfaces.sol": "project/isolated_contracts/CrossChainInterfaces.sol",
    "isolated_contracts/GovernanceMirror.sol": "project/isolated_contracts/GovernanceMirror.sol",
    "isolated_contracts/libs/CrossChainInterfaces.sol": "project/isolated_contracts/libs/CrossChainInterfaces.sol",
    "isolated_contracts/MockLayerZeroEndpoint.sol": "project/isolated_contracts/MockLayerZeroEndpoint.sol",
    "isolated_contracts/ThreatIntelSync.sol": "project/isolated_contracts/ThreatIntelSync.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "paris",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/isolated_contracts/CrossChainInterfaces.sol": {
        "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.19;\n\n// 简化版本的跨链接口，避免外部依赖\ninterface ILayerZeroEndpoint {\n    function send(\n        uint16 _dstChainId,\n        bytes calldata _destination,\n        bytes calldata _payload,\n        address payable _refundAddress,\n        address _zroPaymentAddress,\n        bytes calldata _adapterParams\n    ) external payable;\n    \n    function estimateFees(\n        uint16 _dstChainId,\n        address _userApplication,\n        bytes calldata _payload,\n        bool _payInZRO,\n        bytes memory _adapterParam\n    ) external view returns (uint256 nativeFee, uint256 zroFee);\n}\n\n// 简化的跨链应用基类\nabstract contract LzApp {\n    ILayerZeroEndpoint public lzEndpoint;\n    mapping(uint16 => bytes) public trustedRemoteLookup;\n\n    event UaForceResumeReceive(uint16 indexed _srcChainId, bytes indexed _srcAddress);\n    event UaForceResumeSend(uint16 indexed _dstChainId, bytes indexed _dstAddress);\n\n    error LzAppInvalidEndpoint(address endpoint);\n    error LzAppNoAdapterParams();\n    error LzAppInvalidPath(uint16 srcChainId, bytes trustedRemote, bytes source);\n    error LzAppInsufficientFee(uint256 required, uint256 provided);\n\n    modifier onlyLzEndpoint() {\n        if (msg.sender != address(lzEndpoint)) {\n            revert LzAppInvalidEndpoint(msg.sender);\n        }\n        _;\n    }\n\n    constructor(address _endpoint) {\n        lzEndpoint = ILayerZeroEndpoint(_endpoint);\n    }\n\n    function _lzSend(\n        uint16 _dstChainId,\n        bytes memory _payload,\n        address payable _refundAddress,\n        address _zroPaymentAddress,\n        bytes memory _adapterParams,\n        uint256 _nativeFee\n    ) internal virtual {\n        if (_adapterParams.length == 0) revert LzAppNoAdapterParams();\n\n       lzEndpoint.send{value: _nativeFee}(\n            _dstChainId,\n            trustedRemoteLookup[_dstChainId],\n            _payload,\n            _refundAddress,\n            _zroPaymentAddress,\n            _adapterParams\n        );\n    }\n\n    function _lzReceive(\n        uint16 _srcChainId,\n        bytes memory _srcAddress,\n        uint64 _nonce,\n        bytes memory _payload\n    ) internal virtual;\n}"
      },
      "project/isolated_contracts/GovernanceMirror.sol": {
        "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\nimport \"./libs/CrossChainInterfaces.sol\";\n\n/**\n * @title Governance Mirror 合约\n * @dev 用于在不同链之间镜像治理提案和投票\n * @author OraSRS Protocol\n */\ncontract GovernanceMirror is LzApp {\n    // 提案状态\n    enum ProposalState { Pending, Active, Canceled, Defeated, Succeeded, Queued, Executed }\n    \n    // 提案类型\n    enum ProposalType { ParameterUpdate, ContractUpgrade, EmergencyAction, NodeManagement, ThreatIntelSync }\n\n    // 提案结构\n    struct Proposal {\n        uint256 id;\n        address proposer;\n        uint256 startTime;\n        uint256 endTime;\n        uint256 votesFor;\n        uint256 votesAgainst;\n        uint256 votesAbstain;\n        uint256 requiredQuorum;\n        string description;\n        ProposalType proposalType;\n        ProposalState state;\n        address[] targets;\n        uint256[] values;\n        bytes[] calldatas;\n        uint256 sourceChainId;  // 源链ID\n        string sourceProposalId; // 源链提案ID\n    }\n\n    // 投票结构\n    struct Vote {\n        bool hasVoted;\n        uint8 support;  // 0=Against, 1=For, 2=Abstain\n        uint256 votes;\n    }\n\n    // 跨链提案消息结构\n    struct ProposalMessage {\n        uint256 proposalId;\n        address proposer;\n        uint256 startTime;\n        uint256 endTime;\n        string description;\n        ProposalType proposalType;\n        address[] targets;\n        uint256[] values;\n        bytes[] calldatas;\n        uint256 sourceChainId;\n        string sourceProposalId;\n        uint256 nonce;\n    }\n\n    // 跨链投票消息结构\n    struct VoteMessage {\n        uint256 proposalId;\n        address voter;\n        uint8 support;\n        string reason;\n        uint256 sourceChainId;\n        string sourceProposalId;  // 源提案ID\n        uint256 nonce;\n    }\n\n    // 存储\n    mapping(uint256 => Proposal) public proposals;\n    mapping(uint256 => mapping(address => Vote)) public votes;\n    mapping(bytes32 => bool) public processedMessages;  // 防重放\n    mapping(string => uint256) public sourceProposalToMirror;  // 源提案ID到镜像提案ID映射\n    mapping(uint256 => uint256) public proposalMirrorCount;   // 每个源提案的镜像数量\n    \n    uint256 public proposalCount;\n    address public governanceContract;  // 治理合约地址\n    address public threatIntelSyncContract;  // 威胁情报同步合约地址\n    uint256 public domesticChainId;     // 国内链ID\n    uint256 public overseasChainId;     // 海外界链ID\n    uint256 public quorumPercentage;    // 法定人数百分比 (百万分之一)\n    uint256 public votingPeriod;        // 投票期 (秒)\n\n    // 事件\n    event ProposalCreated(\n        uint256 indexed id,\n        address indexed proposer,\n        uint256 indexed sourceChainId,\n        string sourceProposalId\n    );\n    event VoteCast(\n        uint256 indexed proposalId,\n        address indexed voter,\n        uint8 support,\n        uint256 votes\n    );\n    event ProposalExecuted(uint256 indexed id);\n    event CrossChainProposalReceived(\n        uint256 indexed mirrorProposalId,\n        uint256 indexed sourceProposalId,\n        uint256 indexed sourceChainId\n    );\n    event CrossChainVoteReceived(\n        uint256 indexed proposalId,\n        address indexed voter,\n        uint8 support\n    );\n    event GovernanceUpdated(address oldGovernance, address newGovernance);\n\n    // 修饰符\n    modifier onlyGovernance() {\n        require(msg.sender == governanceContract, \"Only governance can call this function\");\n        _;\n    }\n\n    modifier onlyValidProposal(uint256 proposalId) {\n        require(proposalId > 0 && proposalId <= proposalCount, \"Invalid proposal ID\");\n        _;\n    }\n\n    /**\n     * @dev 构造函数\n     * @param _layerZeroEndpoint LayerZero端点地址\n     * @param _governanceContract 治理合约地址\n     * @param _threatIntelSyncContract 威胁情报同步合约地址\n     * @param _domesticChainId 国内链ID\n     * @param _overseasChainId 海外界链ID\n     */\n    constructor(\n        address _layerZeroEndpoint,\n        address _governanceContract,\n        address _threatIntelSyncContract,\n        uint256 _domesticChainId,\n        uint256 _overseasChainId\n    ) LzApp(_layerZeroEndpoint) {\n        governanceContract = _governanceContract;\n        threatIntelSyncContract = _threatIntelSyncContract;\n        domesticChainId = _domesticChainId;\n        overseasChainId = _overseasChainId;\n        quorumPercentage = 100000;  // 10% 法定人数\n        votingPeriod = 7 days;      // 7天投票期\n    }\n\n    /**\n     * @dev 从LayerZero接收跨链消息 - 实现ILayerZeroReceiver接口\n     * @param _srcChainId 源链ID\n     * @param _srcAddress 源地址\n     * @param _nonce 消息序号\n     * @param _payload 消息负载\n     */\n    function lzReceive(\n        uint16 _srcChainId,\n        bytes calldata _srcAddress,\n        uint64 _nonce,\n        bytes calldata _payload\n    ) external virtual override onlyLzEndpoint {\n        // 解码消息类型标识\n        uint8 messageType = uint8(_payload[0]);\n        \n        if (messageType == 1) {\n            // 提案消息\n            _handleProposalMessage(_srcChainId, _payload);\n        } else if (messageType == 2) {\n            // 投票消息\n            _handleVoteMessage(_srcChainId, _payload);\n        } else {\n            revert(\"Invalid message type\");\n        }\n    }\n\n    /**\n     * @dev 内部LZ接收函数，用于向后兼容\n     */\n    function _lzReceive(\n        uint16 _srcChainId,\n        bytes memory _srcAddress,\n        uint64 _nonce,\n        bytes memory _payload\n    ) internal virtual {\n        // 调用公共的lzReceive函数\n        this.lzReceive(_srcChainId, _srcAddress, _nonce, _payload);\n    }\n\n    /**\n     * @dev 处理提案消息\n     */\n    function _handleProposalMessage(uint16 _srcChainId, bytes memory _payload) internal {\n        // 去掉消息类型标识\n        bytes memory actualPayload = new bytes(_payload.length - 1);\n        for (uint i = 0; i < actualPayload.length; i++) {\n            actualPayload[i] = _payload[i + 1];\n        }\n\n        ProposalMessage memory proposalMsg = abi.decode(actualPayload, (ProposalMessage));\n        \n        // 防重放检查\n        {\n            bytes32 messageId = keccak256(abi.encodePacked(_srcChainId, proposalMsg.sourceProposalId, proposalMsg.nonce));\n            require(!processedMessages[messageId], \"Message already processed\");\n            processedMessages[messageId] = true;\n        }\n\n        // 检查是否需要创建镜像提案\n        string memory mirrorKey = string(abi.encodePacked(proposalMsg.sourceProposalId, \"-\", _toString(_srcChainId)));\n        if (sourceProposalToMirror[mirrorKey] == 0) {\n            // 创建镜像提案\n            uint256 mirrorProposalId = ++proposalCount;\n            \n            Proposal storage newProposal = proposals[mirrorProposalId];\n            newProposal.id = mirrorProposalId;\n            newProposal.proposer = proposalMsg.proposer;\n            newProposal.startTime = proposalMsg.startTime;\n            newProposal.endTime = proposalMsg.endTime;\n            newProposal.votesFor = 0;\n            newProposal.votesAgainst = 0;\n            newProposal.votesAbstain = 0;\n            newProposal.requiredQuorum = 0;  // 镜像提案不设置法定人数\n            newProposal.description = string(abi.encodePacked(\"[MIRROR] \", proposalMsg.description));\n            newProposal.proposalType = proposalMsg.proposalType;\n            newProposal.state = ProposalState.Pending;  // 可能需要根据原提案状态设置\n            newProposal.targets = proposalMsg.targets;\n            newProposal.values = proposalMsg.values;\n            newProposal.calldatas = proposalMsg.calldatas;\n            newProposal.sourceChainId = _srcChainId;\n            newProposal.sourceProposalId = proposalMsg.sourceProposalId;\n            \n            sourceProposalToMirror[mirrorKey] = mirrorProposalId;\n            proposalMirrorCount[proposalMsg.proposalId]++;\n\n            emit CrossChainProposalReceived(mirrorProposalId, proposalMsg.proposalId, _srcChainId);\n        }\n    }\n\n    /**\n     * @dev 处理投票消息\n     */\n    function _handleVoteMessage(uint16 _srcChainId, bytes memory _payload) internal {\n        // 去掉消息类型标识\n        bytes memory actualPayload = new bytes(_payload.length - 1);\n        for (uint i = 0; i < actualPayload.length; i++) {\n            actualPayload[i] = _payload[i + 1];\n        }\n\n        VoteMessage memory voteMsg = abi.decode(actualPayload, (VoteMessage));\n        \n        // 防重放检查\n        {\n            bytes32 messageId = keccak256(abi.encodePacked(_srcChainId, voteMsg.proposalId, voteMsg.voter, voteMsg.nonce));\n            require(!processedMessages[messageId], \"Message already processed\");\n            processedMessages[messageId] = true;\n        }\n\n        // 查找镜像提案\n        string memory mirrorKey = string(abi.encodePacked(voteMsg.sourceProposalId, \"-\", _toString(_srcChainId)));\n        uint256 mirrorProposalId = sourceProposalToMirror[mirrorKey];\n        require(mirrorProposalId > 0, \"Mirror proposal not found\");\n\n        // 记录投票（如果还没有投票）\n        if (!votes[mirrorProposalId][voteMsg.voter].hasVoted) {\n            votes[mirrorProposalId][voteMsg.voter].hasVoted = true;\n            votes[mirrorProposalId][voteMsg.voter].support = voteMsg.support;\n            votes[mirrorProposalId][voteMsg.voter].votes = 100;  // 简化：固定100票\n\n            // 更新提案计票\n            if (voteMsg.support == 1) {\n                proposals[mirrorProposalId].votesFor += 100;\n            } else if (voteMsg.support == 0) {\n                proposals[mirrorProposalId].votesAgainst += 100;\n            } else if (voteMsg.support == 2) {\n                proposals[mirrorProposalId].votesAbstain += 100;\n            }\n\n            emit CrossChainVoteReceived(mirrorProposalId, voteMsg.voter, voteMsg.support);\n        }\n    }\n\n    /**\n     * @dev 从当前链发起跨链提案\n     */\n    function createCrossChainProposal(\n        uint16 _targetChainId,\n        string memory _description,\n        ProposalType _proposalType,\n        address[] memory _targets,\n        uint256[] memory _values,\n        bytes[] memory _calldatas\n    ) external payable returns (uint256 proposalId) {\n        require(_targetChainId == domesticChainId || _targetChainId == overseasChainId, \"Invalid target chain\");\n\n        // 创建源提案\n        proposalId = ++proposalCount;\n        uint256 startTime = block.timestamp;\n        uint256 endTime = startTime + votingPeriod;\n\n        proposals[proposalId] = Proposal({\n            id: proposalId,\n            proposer: msg.sender,\n            startTime: startTime,\n            endTime: endTime,\n            votesFor: 0,\n            votesAgainst: 0,\n            votesAbstain: 0,\n            requiredQuorum: quorumPercentage,\n            description: _description,\n            proposalType: _proposalType,\n            state: ProposalState.Pending,\n            targets: _targets,\n            values: _values,\n            calldatas: _calldatas,\n            sourceChainId: block.chainid,\n            sourceProposalId: string(abi.encodePacked(\"src_\", _toString(proposalId)))\n        });\n\n        // 发送跨链消息\n        ProposalMessage memory proposalMsg = ProposalMessage({\n            proposalId: proposalId,\n            proposer: msg.sender,\n            startTime: startTime,\n            endTime: endTime,\n            description: _description,\n            proposalType: _proposalType,\n            targets: _targets,\n            values: _values,\n            calldatas: _calldatas,\n            sourceChainId: block.chainid,\n            sourceProposalId: string(abi.encodePacked(\"src_\", _toString(proposalId))),\n            nonce: block.timestamp\n        });\n\n        // 编码消息 (添加类型标识)\n        bytes memory encodedMsg = abi.encode(proposalMsg);\n        bytes memory payload = new bytes(encodedMsg.length + 1);\n        payload[0] = 0x01;  // 提案消息类型\n        for (uint i = 0; i < encodedMsg.length; i++) {\n            payload[i + 1] = encodedMsg[i];\n        }\n\n        // 计算费用并发送\n        (uint256 nativeFee, ) = lzEndpoint.estimateFees(_targetChainId, address(this), payload, false, bytes(\"\"));\n        require(msg.value >= nativeFee, \"Insufficient fee\");\n\n        _lzSend(\n            _targetChainId,\n            payload,\n            payable(msg.sender),\n            address(this),\n            bytes(\"\"),\n            nativeFee\n        );\n\n        emit ProposalCreated(proposalId, msg.sender, block.chainid, proposals[proposalId].sourceProposalId);\n    }\n\n    /**\n     * @dev 从当前链发起跨链投票\n     */\n    function castCrossChainVote(\n        uint16 _targetChainId,\n        string memory _sourceProposalId,\n        uint8 _support,\n        string memory _reason\n    ) external payable {\n        require(_targetChainId == domesticChainId || _targetChainId == overseasChainId, \"Invalid target chain\");\n        require(_support <= 2, \"Invalid vote support value\");\n\n        // 发送跨链投票消息\n        VoteMessage memory voteMsg = VoteMessage({\n            proposalId: 0,  // 源链提案ID\n            voter: msg.sender,\n            support: _support,\n            reason: _reason,\n            sourceChainId: block.chainid,\n            sourceProposalId: _sourceProposalId,  // 源提案ID\n            nonce: block.timestamp\n        });\n\n        // 编码消息 (添加类型标识)\n        bytes memory encodedMsg = abi.encode(voteMsg);\n        bytes memory payload = new bytes(encodedMsg.length + 1);\n        payload[0] = 0x02;  // 投票消息类型\n        for (uint i = 0; i < encodedMsg.length; i++) {\n            payload[i + 1] = encodedMsg[i];\n        }\n\n        // 计算费用并发送\n        (uint256 nativeFee, ) = lzEndpoint.estimateFees(_targetChainId, address(this), payload, false, bytes(\"\"));\n        require(msg.value >= nativeFee, \"Insufficient fee\");\n\n        _lzSend(\n            _targetChainId,\n            payload,\n            payable(msg.sender),\n            address(this),\n            bytes(\"\"),\n            nativeFee\n        );\n\n        emit VoteCast(0, msg.sender, _support, 100);  // 简化：固定票数\n    }\n\n    /**\n     * @dev 获取提案详情\n     */\n    function getProposal(uint256 proposalId) external view returns (Proposal memory) {\n        return proposals[proposalId];\n    }\n\n    /**\n     * @dev 获取投票详情\n     */\n    function getVote(uint256 proposalId, address voter) external view returns (Vote memory) {\n        return votes[proposalId][voter];\n    }\n\n    /**\n     * @dev 更新治理合约地址\n     */\n    function updateGovernance(address _newGovernance) external onlyGovernance {\n        address oldGovernance = governanceContract;\n        governanceContract = _newGovernance;\n        emit GovernanceUpdated(oldGovernance, _newGovernance);\n    }\n\n    /**\n     * @dev 更新威胁情报同步合约地址\n     */\n    function updateThreatIntelSyncContract(address _newContract) external onlyGovernance {\n        threatIntelSyncContract = _newContract;\n    }\n\n    /**\n     * @dev 更新法定人数百分比\n     */\n    function updateQuorumPercentage(uint256 _newQuorum) external onlyGovernance {\n        quorumPercentage = _newQuorum;\n    }\n\n    /**\n     * @dev 暂停合约功能\n     */\n    function pause() external onlyGovernance {\n        // _pause(); // 依赖库不存在，使用自定义暂停功能\n    }\n\n    /**\n     * @dev 恢复合约功能\n     */\n    function unpause() external onlyGovernance {\n        // _unpause(); // 依赖库不存在，使用自定义恢复功能\n    }\n\n    /**\n     * @dev 计算提案状态\n     */\n    function state(uint256 proposalId) public view onlyValidProposal(proposalId) returns (ProposalState) {\n        Proposal storage proposal = proposals[proposalId];\n        \n        if (proposal.endTime > block.timestamp) {\n            return ProposalState.Active;\n        } else if (proposal.votesFor <= proposal.votesAgainst || \n                  proposal.votesFor + proposal.votesAgainst < proposal.requiredQuorum) {\n            return ProposalState.Defeated;\n        } else {\n            return ProposalState.Succeeded;\n        }\n    }\n\n    /**\n     * @dev 内部函数：将uint转换为字符串\n     */\n    function _toString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n}"
      },
      "project/isolated_contracts/libs/CrossChainInterfaces.sol": {
        "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\n// LayerZero Endpoint 接口\ninterface ILayerZeroEndpoint {\n    // 事件\n    event PacketSent(\n        uint16 indexed srcChainId,\n        address indexed srcAddress,\n        address indexed dstAddress,\n        uint64 nonce,\n        bytes payload\n    );\n    \n    event PacketReceived(\n        uint16 indexed srcChainId,\n        address indexed srcAddress,\n        address indexed dstAddress,\n        uint64 nonce,\n        bytes payload\n    );\n\n    // 发送跨链消息\n    function send(\n        uint16 _dstChainId,\n        bytes calldata _destination,\n        bytes calldata _payload,\n        address payable _refundAddress,\n        address _zroPaymentAddress,\n        bytes calldata _adapterParams\n    ) external payable;\n    \n    // 估算费用\n    function estimateFees(\n        uint16 _dstChainId,\n        address _userApplication,\n        bytes calldata _payload,\n        bool _payInZRO,\n        bytes memory _adapterParam\n    ) external view returns (uint256 nativeFee, uint256 zroFee);\n    \n    // 接收来自LayerZero的消息\n    function receivePayload(\n        uint16 _srcChainId,\n        bytes calldata _srcAddress,\n        address _dstAddress,\n        uint64 _nonce,\n        uint256 _gasLimit,\n        bytes calldata _payload\n    ) external;\n}\n\n// LayerZero 接收器接口\ninterface ILayerZeroReceiver {\n    function lzReceive(\n        uint16 _srcChainId,\n        bytes calldata _srcAddress,\n        uint64 _nonce,\n        bytes calldata _payload\n    ) external;\n}\n\n// 跨链应用基类\nabstract contract LzApp is ILayerZeroReceiver {\n    ILayerZeroEndpoint public lzEndpoint;\n\n    modifier onlyLzEndpoint() {\n        require(msg.sender == address(lzEndpoint), \"LzApp: invalid endpoint\");\n        _;\n    }\n\n    constructor(address _endpoint) {\n        lzEndpoint = ILayerZeroEndpoint(_endpoint);\n    }\n\n    function _lzSend(\n        uint16 _dstChainId,\n        bytes memory _payload,\n        address payable _refundAddress,\n        address _zroPaymentAddress,\n        bytes memory _adapterParams,\n        uint256 _nativeFee\n    ) internal virtual {\n        require(_adapterParams.length > 0, \"LzApp: no adapter params\");\n\n        lzEndpoint.send{value: _nativeFee}(\n            _dstChainId,\n            abi.encodePacked(address(this)),\n            _payload,\n            _refundAddress,\n            _zroPaymentAddress,\n            _adapterParams\n        );\n    }\n\n    // 子合约需要实现此函数来处理接收到的消息\n    function lzReceive(\n        uint16 _srcChainId,\n        bytes calldata _srcAddress,\n        uint64 _nonce,\n        bytes calldata _payload\n    ) external virtual override;\n}"
      },
      "project/isolated_contracts/MockLayerZeroEndpoint.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// 模拟LayerZero端点，用于测试环境\ncontract MockLayerZeroEndpoint {\n    // 存储跨链消息\n    struct CrossChainMessage {\n        uint16 dstChainId;\n        address dstAddr;\n        bytes payload;\n        address refundAddress;\n        address zroPaymentAddress;\n        bytes adapterParams;\n        uint256 fee;\n        uint256 blockNumber;\n    }\n    \n    CrossChainMessage[] public messages;\n    mapping(uint16 => address) public chainAddresses; // 目标链地址映射\n    \n    event MessageSent(uint256 indexed messageId, uint16 dstChainId, address dstAddr);\n    event MessageReceived(uint256 indexed messageId, uint16 srcChainId, address srcAddr);\n\n    function setChainAddress(uint16 _chainId, address _addr) external {\n        chainAddresses[_chainId] = _addr;\n    }\n\n    function send(\n        uint16 _dstChainId,\n        bytes calldata _destination,\n        bytes calldata _payload,\n        address payable _refundAddress,\n        address _zroPaymentAddress,\n        bytes calldata _adapterParams\n    ) external payable {\n        CrossChainMessage memory msgObj = CrossChainMessage({\n            dstChainId: _dstChainId,\n            dstAddr: address(uint160(bytes20(_destination))),\n            payload: _payload,\n            refundAddress: _refundAddress,\n            zroPaymentAddress: _zroPaymentAddress,\n            adapterParams: _adapterParams,\n            fee: msg.value,\n            blockNumber: block.number\n        });\n        \n        uint256 messageId = messages.length;\n        messages.push(msgObj);\n        \n        emit MessageSent(messageId, _dstChainId, msgObj.dstAddr);\n    }\n\n    function estimateFees(\n        uint16 _dstChainId,\n        address _userApplication,\n        bytes calldata _payload,\n        bool _payInZRO,\n        bytes memory _adapterParam\n    ) external view returns (uint256 nativeFee, uint256 zroFee) {\n        // 简化的费用估算：固定费用\n        nativeFee = 0.1 ether; // 测试环境中使用固定费用\n        zroFee = 0;\n    }\n    \n    function getMessageCount() external view returns (uint256) {\n        return messages.length;\n    }\n}"
      },
      "project/isolated_contracts/ThreatIntelSync.sol": {
        "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\nimport \"./libs/CrossChainInterfaces.sol\";\n\n/**\n * @title Threat Intelligence Sync 合约\n * @dev 用于在不同链之间同步威胁情报数据\n * @author OraSRS Protocol\n */\ncontract ThreatIntelSync is LzApp {\n    // 威胁情报结构\n    struct ThreatIntel {\n        string threatId;              // 威胁ID\n        string sourceIP;              // 源IP\n        uint256 threatLevel;          // 威胁级别\n        uint256 threatType;           // 威胁类型\n        uint256 timestamp;            // 时间戳\n        string evidenceHash;          // 证据哈希\n        string geolocation;           // 地理位置\n        uint256 sourceChainId;        // 源链ID\n        address reporter;             // 报告者地址\n        bool isProcessed;             // 是否已处理\n    }\n\n    // 跨链消息结构\n    struct ThreatMessage {\n        ThreatIntel threat;\n        uint256 nonce;\n    }\n\n    // 存储\n    mapping(bytes32 => ThreatIntel) public threatIntels;  // threatId + chainId -> 威胁情报\n    mapping(bytes32 => bool) public processedMessages;   // 已处理消息防重放\n    address public governanceContract;                     // 治理合约地址\n    uint256 public domesticChainId;                        // 国内链ID\n    uint256 public overseasChainId;                        // 海外界链ID\n\n    // 事件\n    event ThreatIntelReceived(\n        string indexed threatId,\n        string sourceIP,\n        uint256 threatLevel,\n        uint256 indexed sourceChainId,\n        uint256 indexed destChainId\n    );\n    event ThreatIntelSent(\n        string indexed threatId,\n        uint256 indexed sourceChainId,\n        uint256 indexed destChainId\n    );\n    event GovernanceUpdated(address oldGovernance, address newGovernance);\n\n    // 修饰符\n    modifier onlyGovernance() {\n        require(msg.sender == governanceContract, \"Only governance can call this function\");\n        _;\n    }\n\n    /**\n     * @dev 构造函数\n     * @param _layerZeroEndpoint LayerZero端点地址\n     * @param _governanceContract 治理合约地址\n     * @param _domesticChainId 国内链ID\n     * @param _overseasChainId 海外界链ID\n     */\n    constructor(\n        address _layerZeroEndpoint,\n        address _governanceContract,\n        uint256 _domesticChainId,\n        uint256 _overseasChainId\n    ) LzApp(_layerZeroEndpoint) {\n        governanceContract = _governanceContract;\n        domesticChainId = _domesticChainId;\n        overseasChainId = _overseasChainId;\n    }\n\n    /**\n     * @dev 从LayerZero接收跨链消息 - 实现ILayerZeroReceiver接口\n     * @param _srcChainId 源链ID\n     * @param _srcAddress 源地址\n     * @param _nonce 消息序号\n     * @param _payload 消息负载\n     */\n    function lzReceive(\n        uint16 _srcChainId,\n        bytes calldata _srcAddress,\n        uint64 _nonce,\n        bytes calldata _payload\n    ) external virtual override onlyLzEndpoint {\n        // 防重放检查\n        bytes32 messageId = keccak256(abi.encodePacked(_srcChainId, _srcAddress, _nonce));\n        require(!processedMessages[messageId], \"Message already processed\");\n        processedMessages[messageId] = true;\n\n        // 解码威胁情报消息\n        ThreatMessage memory threatMessage = abi.decode(_payload, (ThreatMessage));\n\n        // 验证威胁情报\n        require(bytes(threatMessage.threat.threatId).length > 0, \"Threat ID is required\");\n        require(threatMessage.threat.threatLevel <= 100, \"Invalid threat level\");\n        require(threatMessage.threat.threatType <= 6, \"Invalid threat type\");\n\n        // 存储威胁情报\n        bytes32 threatKey = keccak256(abi.encodePacked(threatMessage.threat.threatId, _srcChainId));\n        threatIntels[threatKey] = threatMessage.threat;\n\n        emit ThreatIntelReceived(\n            threatMessage.threat.threatId,\n            threatMessage.threat.sourceIP,\n            threatMessage.threat.threatLevel,\n            _srcChainId,\n            block.chainid\n        );\n    }\n\n    /**\n     * @dev 内部LZ接收函数，用于向后兼容\n     */\n    function _lzReceive(\n        uint16 _srcChainId,\n        bytes memory _srcAddress,\n        uint64 _nonce,\n        bytes memory _payload\n    ) internal virtual {\n        // 调用公共的lzReceive函数\n        this.lzReceive(_srcChainId, _srcAddress, _nonce, _payload);\n    }\n\n    /**\n     * @dev 发送威胁情报到目标链\n     * @param _dstChainId 目标链ID\n     * @param _threatId 威胁ID\n     * @param _sourceIP 源IP\n     * @param _threatLevel 威胁级别\n     * @param _threatType 威胁类型\n     * @param _evidenceHash 证据哈希\n     * @param _geolocation 地理位置\n     */\n    function sendThreatIntel(\n        uint16 _dstChainId,\n        string memory _threatId,\n        string memory _sourceIP,\n        uint256 _threatLevel,\n        uint256 _threatType,\n        string memory _evidenceHash,\n        string memory _geolocation\n    ) public payable {\n        require(_dstChainId == domesticChainId || _dstChainId == overseasChainId, \"Invalid destination chain\");\n\n        // 构建威胁情报对象\n        ThreatIntel memory threat = ThreatIntel({\n            threatId: _threatId,\n            sourceIP: _sourceIP,\n            threatLevel: _threatLevel,\n            threatType: _threatType,\n            timestamp: block.timestamp,\n            evidenceHash: _evidenceHash,\n            geolocation: _geolocation,\n            sourceChainId: block.chainid,\n            reporter: msg.sender,\n            isProcessed: false\n        });\n\n        // 构建消息\n        ThreatMessage memory threatMessage = ThreatMessage({\n            threat: threat,\n            nonce: block.timestamp\n        });\n\n        // 编码消息\n        bytes memory payload = abi.encode(threatMessage);\n\n        // 计算费用\n        (uint256 nativeFee, ) = lzEndpoint.estimateFees(_dstChainId, address(this), payload, false, bytes(\"\"));\n\n        // 发送跨链消息\n        _lzSend(\n            _dstChainId,\n            payload,\n            payable(msg.sender),\n            address(this), // 退款地址\n            bytes(\"\"), // 附加数据\n            nativeFee\n        );\n\n        // 存储本地记录\n        bytes32 threatKey = keccak256(abi.encodePacked(_threatId, block.chainid));\n        threatIntels[threatKey] = threat;\n\n        emit ThreatIntelSent(_threatId, block.chainid, _dstChainId);\n    }\n\n    /**\n     * @dev 批量发送威胁情报\n     * @param _dstChainId 目标链ID\n     * @param _threatIds 威胁ID数组\n     * @param _sourceIPs 源IP数组\n     * @param _threatLevels 威胁级别数组\n     * @param _threatTypes 威胁类型数组\n     * @param _evidenceHashes 证据哈希数组\n     * @param _geolocations 地理位置数组\n     */\n    function batchSendThreatIntel(\n        uint16 _dstChainId,\n        string[] memory _threatIds,\n        string[] memory _sourceIPs,\n        uint256[] memory _threatLevels,\n        uint256[] memory _threatTypes,\n        string[] memory _evidenceHashes,\n        string[] memory _geolocations\n    ) external payable {\n        require(_threatIds.length == _sourceIPs.length, \"Array length mismatch\");\n        require(_threatIds.length == _threatLevels.length, \"Array length mismatch\");\n        require(_threatIds.length == _threatTypes.length, \"Array length mismatch\");\n        require(_threatIds.length == _evidenceHashes.length, \"Array length mismatch\");\n        require(_threatIds.length == _geolocations.length, \"Array length mismatch\");\n        require(_dstChainId == domesticChainId || _dstChainId == overseasChainId, \"Invalid destination chain\");\n\n        for (uint i = 0; i < _threatIds.length; i++) {\n            sendThreatIntel(\n                _dstChainId,\n                _threatIds[i],\n                _sourceIPs[i],\n                _threatLevels[i],\n                _threatTypes[i],\n                _evidenceHashes[i],\n                _geolocations[i]\n            );\n        }\n    }\n\n    /**\n     * @dev 获取威胁情报详情\n     * @param _threatId 威胁ID\n     * @param _chainId 链ID\n     */\n    function getThreatIntel(string memory _threatId, uint256 _chainId) external view returns (ThreatIntel memory) {\n        bytes32 threatKey = keccak256(abi.encodePacked(_threatId, _chainId));\n        return threatIntels[threatKey];\n    }\n\n    /**\n     * @dev 更新治理合约地址\n     * @param _newGovernance 新治理合约地址\n     */\n    function updateGovernance(address _newGovernance) external onlyGovernance {\n        address oldGovernance = governanceContract;\n        governanceContract = _newGovernance;\n        emit GovernanceUpdated(oldGovernance, _newGovernance);\n    }\n\n    /**\n     * @dev 暂停合约功能\n     */\n    function pause() external onlyGovernance {\n        // _pause(); // 依赖库不存在，使用自定义暂停功能\n    }\n\n    /**\n     * @dev 恢复合约功能\n     */\n    function unpause() external onlyGovernance {\n        // _unpause(); // 依赖库不存在，使用自定义恢复功能\n    }\n\n    /**\n     * @dev 从其他链接收消息时支付的费用\n     */\n    function quoteSendThreatIntel(\n        uint16 _dstChainId,\n        string memory _threatId,\n        string memory _sourceIP,\n        uint256 _threatLevel,\n        uint256 _threatType,\n        string memory _evidenceHash,\n        string memory _geolocation\n    ) public view returns (uint256 fee) {\n        ThreatIntel memory threat = ThreatIntel({\n            threatId: _threatId,\n            sourceIP: _sourceIP,\n            threatLevel: _threatLevel,\n            threatType: _threatType,\n            timestamp: block.timestamp,\n            evidenceHash: _evidenceHash,\n            geolocation: _geolocation,\n            sourceChainId: block.chainid,\n            reporter: msg.sender,\n            isProcessed: false\n        });\n\n        ThreatMessage memory threatMessage = ThreatMessage({\n            threat: threat,\n            nonce: block.timestamp\n        });\n\n        bytes memory payload = abi.encode(threatMessage);\n        (fee, ) = lzEndpoint.estimateFees(_dstChainId, address(this), payload, false, bytes(\"\"));\n    }\n}"
      }
    }
  }
}