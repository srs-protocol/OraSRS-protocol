\section{Commit-Reveal Consensus Mechanism}

\subsection{Mechanism Overview}

The Commit-Reveal mechanism in OraSRS prevents front-running attacks and ensures fair threat intelligence submission by separating the commitment phase from the revelation phase. This mechanism is critical for preventing malicious actors from manipulating threat reports based on public information.

\subsection{Algorithm Definition}

\begin{algorithm}[H]
\caption{OraSRS Commit-Reveal Threat Reporting}
\begin{algorithmic}[1]
\REQUIRE{Node $n_i$ with threat intelligence $TI$, secret randomness $r_i$}
\ENSURE{Valid threat report in consensus}
\STATE{\textbf{Commit Phase:}}
\STATE{$hash_i = Hash(TI || r_i)$} \COMMENT{Hash threat data with randomness}
\STATE{Submit $hash_i$ to commitment contract} \COMMENT{Public commitment}
\STATE{\textbf{Reveal Phase:}}
\STATE{Wait for commitment window to close}
\STATE{Submit $TI$ and $r_i$ to revelation contract}
\STATE{Verify $Hash(TI || r_i) == hash_i$}
\IF{Verification succeeds}
\STATE{Process threat intelligence}
\ELSE
\STATE{Penalize node for invalid revelation}
\ENDIF
\end{algorithmic}
\label{alg:commit_reveal}
\end{algorithm}

\subsection{Security Properties}

The Commit-Reveal mechanism provides several critical security properties:

\subsubsection{Front-Running Prevention}
By committing to a hash of the threat data before revealing it, malicious nodes cannot observe other nodes' reports and adjust their own reports accordingly.

\subsubsection{Time Independence}
The revelation phase begins only after all commitments are received, ensuring that nodes cannot gain advantage by timing their reveals.

\subsubsection{Data Integrity}
The cryptographic binding between commitment and revelation ensures that the revealed data matches the committed data.

\subsection{Smart Contract Implementation}

\begin{lstlisting}[caption={OraSRS Commit-Reveal Contract}, language=Solidity, basicstyle=\ttfamily\small]
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

contract OraSRSCommitReveal {
    struct Commitment {
        bytes32 commitmentHash;
        address committer;
        uint256 commitTime;
        bool revealed;
    }
    
    struct ThreatReport {
        string ip;
        uint8 threatLevel;
        string threatType;
        uint256 timestamp;
        address reporter;
    }
    
    // Mapping for commitments
    mapping(bytes32 => Commitment) public commitments;
    // Array for revealed reports
    ThreatReport[] public revealedReports;
    
    uint256 public commitPhaseDuration;
    uint256 public revealPhaseStart;
    uint256 public revealPhaseDuration;
    
    event CommitmentSubmitted(address indexed committer, bytes32 indexed commitmentHash);
    event ThreatReportRevealed(address indexed reporter, string ip, uint8 threatLevel);
    event CommitmentWindowClosed();
    
    constructor(uint256 _commitDuration, uint256 _revealDuration) {
        commitPhaseDuration = _commitDuration;
        revealPhaseDuration = _revealDuration;
        revealPhaseStart = 0;
    }
    
    modifier inCommitPhase() {
        require(
            revealPhaseStart == 0 || block.timestamp < revealPhaseStart,
            "Commit phase has ended"
        );
        _;
    }
    
    modifier inRevealPhase() {
        require(
            revealPhaseStart > 0 && 
            block.timestamp >= revealPhaseStart && 
            block.timestamp < revealPhaseStart + revealPhaseDuration,
            "Not in reveal phase"
        );
        _;
    }
    
    function commitThreatReport(
        bytes32 commitmentHash
    ) external inCommitPhase {
        require(commitments[commitmentHash].committer == address(0), 
                "Commitment already exists");
        
        commitments[commitmentHash] = Commitment({
            commitmentHash: commitmentHash,
            committer: msg.sender,
            commitTime: block.timestamp,
            revealed: false
        });
        
        emit CommitmentSubmitted(msg.sender, commitmentHash);
    }
    
    function revealThreatReport(
        string memory ip,
        uint8 threatLevel,
        string memory threatType,
        bytes32 randomness
    ) external inRevealPhase {
        bytes32 commitmentHash = keccak256(abi.encodePacked(ip, threatLevel, threatType, msg.sender, randomness));
        Commitment storage commitment = commitments[commitmentHash];
        
        require(commitment.committer != address(0), "No such commitment");
        require(commitment.committer == msg.sender, "Not committer");
        require(!commitment.revealed, "Already revealed");
        
        commitment.revealed = true;
        
        revealedReports.push(ThreatReport({
            ip: ip,
            threatLevel: threatLevel,
            threatType: threatType,
            timestamp: block.timestamp,
            reporter: msg.sender
        }));
        
        emit ThreatReportRevealed(msg.sender, ip, threatLevel);
    }
    
    function closeCommitPhase() external {
        require(revealPhaseStart == 0, "Commit phase already closed");
        revealPhaseStart = block.timestamp;
        emit CommitmentWindowClosed();
    }
    
    function getRevealedReportCount() external view returns (uint256) {
        return revealedReports.length;
    }
}
\end{lstlisting}

\subsection{Economic Analysis of Commit-Reveal}

The Commit-Reveal mechanism introduces economic considerations that enhance security:

\subsubsection{Cost of Manipulation}
To manipulate the threat reporting process, an attacker must:
\begin{enumerate}
\item Submit a commitment with their desired threat data and randomness
\item Hope no other valid commitments affect the outcome
\item Face potential slashing if their report is found to be malicious
\end{enumerate}

The cost of this attack path is significantly higher than the potential benefit.

\subsubsection{Validator Incentive Alignment}
Validators are incentivized to participate honestly in the Commit-Reveal process because:
\begin{itemize}
\item Honest participation leads to consistent rewards
\item Malicious participation risks slashing penalties
\item The reputation system rewards consistent, accurate reporting
\end{itemize}

\subsection{Resistance to Lazy Validators}

The Commit-Reveal mechanism specifically addresses the "lazy validator" problem:

\begin{itemize}
\item \textbf{Forced Participation}: Validators must participate in both commit and reveal phases
\item \textbf{Verification Requirement}: Revealed data must match committed hash
\item \textbf{Penalty for Non-participation}: Validators who fail to reveal face penalties
\end{itemize}

This ensures that validators cannot simply copy other validators' revealed data without first making their own commitment, maintaining the security properties of the consensus mechanism.
