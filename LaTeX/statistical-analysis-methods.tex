\section{实验统计分析方法}

\subsection{理论形式化框架}

\subsubsection{威胁情报评估模型}

定义威胁情报评估为一个多元函数：
\begin{equation}
TIE = f(R, D, C, T)
\end{equation}

其中：
\begin{itemize}
\item $TIE$：威胁情报评估 (Threat Intelligence Evaluation)
\item $R$：可靠性 (Reliability)，$R \in [0, 1]$
\item $D$：时效性 (Duration)，$D \in \mathbb{R}^+$
\item $C$：一致性 (Consistency)，$C \in [0, 1]$
\item $T$：时间维度 (Temporal Factor)
\end{itemize}

具体函数定义为：
\begin{equation}
TIE = \alpha \cdot R + \beta \cdot e^{-\lambda D} \cdot C + \gamma \cdot T(t)
\end{equation}

其中 $\alpha + \beta + \gamma = 1$，且 $\alpha, \beta, \gamma > 0$。

\subsubsection{风险评分函数}

风险评分 $RS$ 的一般形式为：
\begin{equation}
RS = \sum_{i=1}^{n} w_i \cdot s_i \cdot d(t_i) \cdot m_j
\end{equation}

其中：
\begin{itemize}
\item $w_i$：威胁类型权重
\item $s_i$：威胁严重程度评分
\item $d(t_i)$：时间衰减函数
\item $m_j$：来源可信度乘数
\end{itemize}

时间衰减函数定义为：
\begin{equation}
d(t) = 
\begin{cases} 
1.0 - \frac{t}{\tau_1} & \text{if } t \leq \tau_1 \\
\delta \cdot e^{-\frac{t-\tau_1}{\tau_2}} & \text{if } t > \tau_1
\end{cases}
\end{equation}

其中 $\tau_1 = 24$ 小时，$\tau_2 = 24$ 小时，$\delta = 0.5$。

\subsubsection{性能指标函数}

\paragraph{吞吐量函数}
\begin{equation}
TPS = \frac{N_{requests}}{T_{duration}}
\end{equation}

\paragraph{延迟函数}
\begin{equation}
L_{avg} = \frac{1}{N} \sum_{i=1}^{N} L_i
\end{equation}

\paragraph{成功率函数}
\begin{equation}
SR = \frac{N_{success}}{N_{total}} \times 100\%
\end{equation}

\subsection{统计指标定义与计算}

\subsubsection{基本统计指标}

\paragraph{均值 (Mean)}
\begin{equation}
\bar{x} = \frac{1}{n} \sum_{i=1}^{n} x_i
\end{equation}

\paragraph{方差 (Variance)}
\begin{equation}
\sigma^2 = \frac{1}{n-1} \sum_{i=1}^{n} (x_i - \bar{x})^2
\end{equation}

\paragraph{标准差 (Standard Deviation)}
\begin{equation}
\sigma = \sqrt{\frac{1}{n-1} \sum_{i=1}^{n} (x_i - \bar{x})^2}
\end{equation}

\paragraph{分位数 (Quantiles)}
对于 $p$-分位数 ($0 < p < 1$)：
\begin{equation}
Q(p) = F^{-1}(p)
\end{equation}

其中 $F$ 是累积分布函数。

\subsubsection{性能评估指标}

\paragraph{分位数延迟}
\begin{align}
Q_{50\%} &= \text{median}(L_1, L_2, ..., L_n) \\
Q_{95\%} &= \text{95th percentile of delays} \\
Q_{99\%} &= \text{99th percentile of delays}
\end{align}

\subsubsection{机器学习评估指标}

\paragraph{混淆矩阵相关指标}
设混淆矩阵为：
\begin{equation}
\begin{bmatrix}
TN & FP \\
FN & TP
\end{bmatrix}
\end{equation}

其中：
\begin{itemize}
\item $TP$：真正例 (True Positives)
\item $TN$：真负例 (True Negatives)
\item $FP$：假正例 (False Positives)
\item $FN$：假负例 (False Negatives)
\end{itemize}

\paragraph{精确率 (Precision)}
\begin{equation}
Precision = \frac{TP}{TP + FP}
\end{equation}

\paragraph{召回率 (Recall)}
\begin{equation}
Recall = \frac{TP}{TP + FN}
\end{equation}

\paragraph{F1分数 (F1-Score)}
\begin{equation}
F1 = 2 \cdot \frac{Precision \cdot Recall}{Precision + Recall}
\end{equation}

\paragraph{特异度 (Specificity)}
\begin{equation}
Specificity = \frac{TN}{TN + FP}
\end{equation}

\paragraph{准确率 (Accuracy)}
\begin{equation}
Accuracy = \frac{TP + TN}{TP + TN + FP + FN}
\end{equation}

\paragraph{假正例率 (False Positive Rate)}
\begin{equation}
FPR = \frac{FP}{FP + TN} = 1 - Specificity
\end{equation}

\paragraph{假负例率 (False Negative Rate)}
\begin{equation}
FNR = \frac{FN}{FN + TP} = 1 - Recall
\end{equation}

\subsubsection{AUC-ROC指标}

ROC曲线下面积定义为：
\begin{equation}
AUC = \int_0^1 ROC(TPR, FPR) \, dFPR = \int_0^1 TPR(FPR) \, dFPR
\end{equation}

其中：
\begin{align}
TPR &= \frac{TP}{TP + FN} \quad \text{(True Positive Rate)} \\
FPR &= \frac{FP}{FP + TN} \quad \text{(False Positive Rate)}
\end{align}

\subsection{实验设计与数据收集}

\subsubsection{实验变量定义}

\begin{itemize}
\item \textbf{自变量 (Independent Variables):}
  \begin{itemize}
  \item 网络延迟 (Network Latency)
  \item 节点数量 (Node Count)
  \item 威胁类型 (Threat Type)
  \item 数据规模 (Data Scale)
  \end{itemize}
  
\item \textbf{因变量 (Dependent Variables):}
  \begin{itemize}
  \item 响应时间 (Response Time)
  \item 准确率 (Accuracy)
  \item 吞吐量 (Throughput)
  \item 内存使用 (Memory Usage)
  \end{itemize}
  
\item \textbf{控制变量 (Control Variables):}
  \begin{itemize}
  \item 硬件配置 (Hardware Specifications)
  \item 软件版本 (Software Versions)
  \item 网络环境 (Network Environment)
  \end{itemize}
\end{itemize}

\subsubsection{数据收集方法}

\begin{enumerate}
\item \textbf{实时监控}: 通过内置监控模块记录系统性能指标
\item \textbf{日志分析}: 从系统日志中提取性能和功能指标
\item \textbf{统计采样}: 对大规模数据进行分层抽样统计
\item \textbf{基准测试}: 使用标准化测试数据集进行对比评估
\end{enumerate}

\subsection{统计分析方法}

\subsubsection{描述性统计分析}

对收集到的数据进行描述性统计分析：

\begin{equation}
\begin{aligned}
\text{样本均值} & : \bar{X} = \frac{1}{n}\sum_{i=1}^{n} X_i \\
\text{样本方差} & : S^2 = \frac{1}{n-1}\sum_{i=1}^{n}(X_i - \bar{X})^2 \\
\text{样本标准差} & : S = \sqrt{S^2} \\
\text{偏度} & : Skew = \frac{1}{n}\sum_{i=1}^{n}\left(\frac{X_i - \bar{X}}{S}\right)^3 \\
\text{峰度} & : Kurt = \frac{1}{n}\sum_{i=1}^{n}\left(\frac{X_i - \bar{X}}{S}\right)^4 - 3
\end{aligned}
\end{equation}

\subsubsection{推断性统计分析}

\paragraph{置信区间}
对于均值的 $1-\alpha$ 置信区间：
\begin{equation}
CI = \left[\bar{X} - t_{\alpha/2, n-1} \cdot \frac{S}{\sqrt{n}}, \bar{X} + t_{\alpha/2, n-1} \cdot \frac{S}{\sqrt{n}}\right]
\end{equation}

\paragraph{假设检验}
采用双样本t检验比较不同条件下的性能差异：
\begin{equation}
t = \frac{\bar{X}_1 - \bar{X}_2}{\sqrt{\frac{S_1^2}{n_1} + \frac{S_2^2}{n_2}}}
\end{equation}

\subsection{实验验证与结果分析}

\subsubsection{统计显著性检验}

使用 $p$-value 进行统计显著性检验：
\begin{equation}
p\text{-value} = P(T \geq t | H_0)
\end{equation}

其中 $H_0$ 为零假设，$T$ 为检验统计量。

\subsubsection{效应量计算}

计算Cohen's d效应量：
\begin{equation}
d = \frac{\bar{X}_1 - \bar{X}_2}{S_{pooled}}
\end{equation}

其中 $S_{pooled}$ 为合并标准差：
\begin{equation}
S_{pooled} = \sqrt{\frac{(n_1-1)S_1^2 + (n_2-1)S_2^2}{n_1 + n_2 - 2}}
\end{equation}

效应量解释：
\begin{itemize}
\item $d = 0.2$：小效应
\item $d = 0.5$：中等效应
\item $d = 0.8$：大效应
\end{itemize}

\subsection{实验结果统计汇总}

基于实验日志数据的统计分析结果：

\subsubsection{性能测试统计}
\begin{itemize}
\item \textbf{本地测试}：
  \begin{itemize}
  \item 样本数量：$n = 10,000$ IP
  \item 平均处理时间：$\bar{x} = 0.0334$ ms/IP
  \item 标准差：$\sigma = ?$ (需从日志计算)
  \item 95\%分位数：$Q_{95} = ?$ (需从日志计算)
  \item 吞吐量：$29,940.12$ RPS
  \end{itemize}
  
\item \textbf{云端测试}：
  \begin{itemize}
  \item 样本数量：$n = 1,000$ IP
  \item 平均处理时间：$\bar{x} = 102.44$ ms/IP
  \item 标准差：$\sigma = ?$ (需从日志计算)
  \item 95\%分位数：$Q_{95} = ?$ (需从日志计算)
  \item 吞吐量：$9.76$ RPS
  \end{itemize}
\end{itemize}

\subsubsection{精度测试统计}
基于 precision-sybil-test-results 数据：
\begin{itemize}
\item \textbf{精确率}：$Precision = 0.7581$
\item \textbf{召回率}：$Recall = 0.9114$
\item \textbf{F1分数}：$F1 = 0.8277$
\item \textbf{准确率}：$Accuracy = 0.9452$
\item \textbf{女巫攻击抑制率}：$0.9985$
\end{itemize}

\subsubsection{跨区域性能统计}
\begin{table}[H]
\centering
\begin{tabular}{@{}lcccc@{}}
\toprule
\textbf{区域} & \textbf{成功率} & \textbf{平均延迟} & \textbf{标准差} & \textbf{95\%分位数} \\
\midrule
亚洲（0-50ms） & 97.67\% & 45.95ms & ? & ? \\
欧洲（50-100ms） & 92.22\% & 95.68ms & ? & ? \\
北美（100-150ms） & 85.33\% & 145.39ms & ? & ? \\
南美（150-200ms） & 84.00\% & 194.99ms & ? & ? \\
大洋洲（200-250ms） & 78.75\% & 246.01ms & ? & ? \\
非洲（250-300ms） & 70.00\% & 294.21ms & ? & ? \\
\bottomrule
\end{tabular}
\caption{跨区域性能测试统计分析结果}
\label{tab:cross_region_detailed_stats}
\end{table}

\subsection{统计分析代码实现}

为了从日志文件中提取完整的统计信息，我们提供了分析脚本：

\begin{lstlisting}[caption={Python统计分析脚本示例}]
import json
import numpy as np
from scipy import stats
import os
from pathlib import Path

def analyze_log_files(log_dir):
    """分析日志文件并提取统计信息"""
    log_files = Path(log_dir).glob("*.json")
    
    performance_data = []
    precision_recall_data = []
    
    for log_file in log_files:
        with open(log_file, 'r') as f:
            data = json.load(f)
            
        # 提取性能数据
        if 'test_summary' in data:
            summary = data['test_summary']
            if 'avg_time_per_query_ms' in summary:
                performance_data.append(float(summary['avg_time_per_query_ms']))
        
        # 提取精确率/召回率数据
        if 'precisionRecallTest' in data:
            pr_data = data['precisionRecallTest']
            precision_recall_data.append({
                'precision': pr_data['precision'],
                'recall': pr_data['recall'],
                'f1_score': pr_data['f1Score'],
                'accuracy': pr_data['accuracy']
            })
    
    # 计算统计指标
    if performance_data:
        perf_stats = {
            'mean': np.mean(performance_data),
            'std': np.std(performance_data),
            'median': np.median(performance_data),
            'q95': np.percentile(performance_data, 95),
            'q99': np.percentile(performance_data, 99),
            'min': np.min(performance_data),
            'max': np.max(performance_data),
            'count': len(performance_data)
        }
        
    if precision_recall_data:
        pr_array = np.array([list(d.values()) for d in precision_recall_data])
        pr_stats = {
            'precision': {
                'mean': np.mean(pr_array[:, 0]),
                'std': np.std(pr_array[:, 0]),
                'range': (np.min(pr_array[:, 0]), np.max(pr_array[:, 0]))
            },
            'recall': {
                'mean': np.mean(pr_array[:, 1]),
                'std': np.std(pr_array[:, 1]),
                'range': (np.min(pr_array[:, 1]), np.max(pr_array[:, 1]))
            },
            'f1_score': {
                'mean': np.mean(pr_array[:, 2]),
                'std': np.std(pr_array[:, 2]),
                'range': (np.min(pr_array[:, 2]), np.max(pr_array[:, 2]))
            }
        }
    
    return perf_stats, pr_stats

# 使用示例
log_dir = "/path/to/logs"
perf_stats, pr_stats = analyze_log_files(log_dir)

print("性能统计结果:")
for key, value in perf_stats.items():
    print(f"{key}: {value}")

print("\n精确率/召回率统计结果:")
for category, stats in pr_stats.items():
    print(f"{category}:")
    for stat_name, stat_value in stats.items():
        print(f"  {stat_name}: {stat_value}")
\end{lstlisting}

通过上述理论形式化和统计分析方法，我们能够更全面地评估OraSRS协议的性能和安全性，为系统优化和改进提供科学依据。
